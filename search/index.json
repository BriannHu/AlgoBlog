[{"content":"Overview Morris Traversal is a tree traversal algorithm that does not use a stack or recursion. In the algorithm, links between different nodes are temporarily created, and are reverted upon traversal to restore the original tree.\nProblem Given a node root of a tree, perform an inorder traversal of the tree without using a stack or recursion.\nAlgorithm Initialize curr as root. While curr is not null: If curr.left is null: Print curr\u0026rsquo;s data. Continue right, set curr as curr.right. Else: In the left subtree, make curr the right child of the rightmost node. Continue left, set curr as curr.left. Implementation def inorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: res = [] curr = root while curr: if not curr.left: res.append(curr.val) curr = curr.right else: prev = curr.left while prev.right and prev.right != curr: prev = prev.right if not prev.right: prev.right = curr curr = curr.left else: prev.right = None # recovers the tree (optional) res.append(curr.val) curr = curr.right return res Analysis Time Complexity $O(n)$: It might appear at first that the time complexity is $O(nlogn)$, given that finding the predecessor nodes for each node seems to take $O(logn)$, proportional to the height of the tree. However, finding all the predecessor nodes can be found in $O(n)$ time. Thus, the overall time complexity will be $O(n)$, with one pass to find all the predecessor nodes, and another pass to process all the nodes.\nSpace Complexity $O(1)$: No extra space is used besides the node pointers which use constant space.\nExplanation The following section explains some of the motivation behind the Morris Traversal algorithm, and is inspired by its Wikipedia page.\nMotivation In The Art of Computer Programming, Donald Knuth speculated about the existence of a non-recursive algorithm for in-order traversal, which uses no stack and leaves the tree unmodified. Such an algorithm would prove useful for a hypothetical scenario involving traversing an infinite binary tree, which would be unable to be traversed using the typical recursive or stack-based algorithm.\nA solution to this is tree threading, which was presented by Joseph M. Morris in 1979.\nThreaded Binary Tree A threaded binary tree is a variation of the classic binary tree which facilitates traversal by incorporating threading links which point from certain nodes to others.\nA binary tree is threaded by making all right child pointers that would normally be null point to the in-order successor of the node (if it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node.\nCertain use cases arise from the need of different traversal orders; for example, a tree may have nodes representing people and is sorted by names, but have extra threads which allow for quick traversal in order of birth date, or other characteristics.\nVariations Binary Tree Inorder Traversal Binary Tree Preorder Traversal Binary Tree Postorder Traversal ","date":"2023-11-04T00:00:00Z","permalink":"https://briannhu.github.io/AlgoBlog/p/morris-traversal/","title":"Morris Traversal"},{"content":"Overview Binary search is a search algorithm that returns the index of a target value within a sorted array. Instead of iterating through each element of the array, it utilizes the sorted nature of the array to search more efficiently and improve the time complexity from $O(n)$ to $O(logn)$.\nProblem Given a sorted array nums and a target value T, return the index of T or -1 if it doesn\u0026rsquo;t exist.\nAlgorithm Initialize a left boundary $L=0$ and a right boundary $R=length($nums$)$ Initialize a middle pointer $M = (L + R) / 2$ If the value at index $M$ is ever equal to T, return $M$; otherwise shrink $L$ or $R$ accordingly If no value is equal to T, return $-1$ Implementation Variation 1: Return Early def search(self, nums: List[int], target: int) -\u0026gt; int: left, right = 0, len(nums)-1 while left \u0026lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] \u0026gt; target: right = mid - 1 else: left = mid + 1 return -1 Variation 2: Return After Exiting def search(self, nums: List[int], target: int) -\u0026gt; int: left, right = 0, len(nums)-1 while left \u0026lt; right: mid = (left + right) // 2 if nums[mid] \u0026gt;= target: right = mid else: left = mid + 1 return left if nums[left] == target else -1 Analysis Time Complexity $O(logn)$: In the worst case, there are $O(logn)$ comparisons made where $n$ is the number of array elements. The entire array will be searched, where half the array is discarded after every iteration.\nSpace Complexity $O(1)$: There are no additional data structures used.\nExplanation While the overall algorithm is straightforward, binary search\u0026rsquo;s implementation can be tricky due to different edge cases and variations. The following sections were heavily inspired by this Leetcode discussion.\nLeft/Right Boundaries When searching for a target in a sorted array, these pointers are almost always initialized as:\nleft, right = 0, len(nums) - 1 However, both pointers must cover the entire search space. If the problem was instead \u0026ldquo;Find the insert position\u0026rdquo;, it is possible to insert after the last element. In this case, the boundaries would be initialized as:\nleft, right = 0, len(nums) Middle Pointer Calculation The standard middle pointer calculation is:\nmid = (left + right) // 2 However, there are two subtleties to consider: overflow and even middle selection.\n1. Overflow\nLanguages with signed integers (ie. Java, C++) have the possibility of overflowing from arithmetic operations. To circumvent this, the following calculation can be used instead:\nmid = left + (right - left) // 2 2. Even Middle Selection\nIn arrays with an even number of elements, there are two possibitilies for the \u0026ldquo;middle\u0026rdquo; element; it can either be the element on the middle left or the middle right.\nmid = left + (right - left) // 2 | [1, 2, 3, 4, 5, 6] | mid = left + (right - left + 1) // 2 This selection will directly affect how the boundaries should be shrunk, as the wrong choice can lead to an infinite loop.\nWhile Loop Condition Two common options for the while loop condition are while l \u0026lt;= r and while l \u0026lt; r.\n1. while l \u0026lt;= r\nThis should be used when the result is returned from inside the loop. The termination condition is when l \u0026gt; r, which signifies that the array does not contain the target. Note that this may not apply to all questions, as not all problems involve searching for the existence of a target.\n2. while l \u0026lt; r\nThis should be used when the result is returned from outside the loop. The termination condition is when l == r, which signifies when the loop exits that the two boundaries point to the same value, presumably the target.\nShrinking the Boundaries Shrinking the boundary will depend on whether the value at the current index is greater or less than the target. If the value is greater, then that means the target is guaranteed to be on its left (since the array is sorted), so the right boundary is moved. If the value is less than the target, then the target will be on its right, so the left boundary is moved.\nThere are two possibilities to consider when shrinking the boundaries - whether to include the middle pointer or not. This will depend on both the middle pointer calculation and the conditional check prior to the boundary move.\nAssuming a while condition of l \u0026lt; r, the following would not work:\nmid = left + (right - left) // 2 # this line is incorrect if nums[mid] \u0026gt; target: # given this condition right = mid - 1 else: left = mid This can be fixed by changing the conditional to include the target value:\nmid = left + (right - left) // 2 if nums[mid] \u0026gt;= target: # correct right = mid - 1 else: left = mid Or by rounding the middle pointer up during its calculation:\nmid = left + (right - left + 1) // 2 # correct if nums[mid] \u0026gt; target: right = mid - 1 else: left = mid A trick to easily verify if the middle pointer calculation and boundary shrinking logic are correct is to visualize how it would behave on an array with two elements. If the logic is incorrect, then the boundaries won\u0026rsquo;t move which will result in an infinite loop.\nVariations Search in Rotated Sorted Array Find Minimum in Sorted Array Find Minimum in Sorted Array with Duplicates Search in a 2D Matrix ","date":"2023-10-22T00:00:00Z","permalink":"https://briannhu.github.io/AlgoBlog/p/binary-search/","title":"Binary Search"},{"content":"Welcome to my blog!\nSince starting to work full-time, I\u0026rsquo;ve found myself missing the late night hours of coding and coffee. To relive those moments\u0026hellip; I\u0026rsquo;ve decided to create a blog. I\u0026rsquo;m creating this using the Hugo framework with Jimmy Cai\u0026rsquo;s Stack Theme, so I can focus more on the content itself (besides, who likes frontend?).\nHere, I\u0026rsquo;ll be documenting a list of algorithms and data structures that I find useful or interesting, with heavy inspiration from:\nLeetcode Neetcode Introduction to Algorithms, by CLRS For easier navigation, use the handy search function that this theme provides, or filter by catagories/tags.\nHope you enjoy!\n\u0026ndash; Brian\n","date":"2023-10-22T00:00:00Z","permalink":"https://briannhu.github.io/AlgoBlog/p/hello-world/","title":"Hello World!"}]